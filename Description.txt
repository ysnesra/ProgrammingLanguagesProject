
CQRS tasarýmý ile MediatR kütüphanesini kullandýðým WebAPI projesidir.
DDD(Domain Dream Development) Tekniði ile Onion Architecture mimarisi kullanýlmýþtýr

Programlama Dilleri ve teknolojilerinin bulunduðu bir uygulamadýr.

*******************************************************************************
Programlama dillerini(C#,Java,Python) ekleyebilecek, silebilecek, güncelleyebilecek, listeleyebilecek, id ile getirebilecek kodlar yazýldý.
  Ýsimler tekrar edemez.
  Programlama dili boþ geçilemez.

1.AÞAMA
  Proje klasör yapýsý oluþturuldu.
  Solution Folder'dan "corePackges" klasörü oluþturuldu.Bu Mimari kýsmý EnginDemirog'un "devarchitecture" sitesinden(githubDan) hazýr olarak alýndý
  DevsProject ksýmýnda da projenin katmanlarý oluþturuldu.Klasör yapýlandýrmalarý yapýldý.

2.AÞAMA
  *Language -> Domain entitysi oluþturuldu.
  *Persistence -> BaseDbContext.cs oluþturuldu.
  *Application -> ILanguageRepository.cs oluþturuldu. Soyut sýnýflar Application katmanýnda
  *Persistence -> LanguageRepository.cs oluþturuldu. Repositoryler(CRUD iþlemleri) Persistence katmanýnda
  *Bütün katmanlar kendi Registirationlarýný (injectionlarýný) kendi halletsin mantýðý ile:
   PersistenceServiceRegistration.cs
   ApplicationServiceRegistration.cs oluþturuldu.Bu servisleri program.cs'ye de ekledim.
  *Veritabaný baðlantýsý için appsettings'e ConnectionString yazýldý
  *CodeFirst yapýsý ile migration yapýlarak ProgrammingLanguagesDb databasei oluþturuldu.

3.AÞAMA
  Application katmanýnda Features klasöründe -> Command ve Query operasyonlarý ayrýldý. 
  Command kýsmý kodlandý.
    *Application katmanýna -> AutoMapper ve MediatR kütüphaneleri eklendi.
    *CreateLanguageCommand.cs clasý oluþturuldu.MediatR handle iþleminin gerçekleþtiði class
    *MappingProfiles.cs clasýnda neyi neyle mapleyeceði yazýldý
 
  Bütün Contollerlar da MediatR kullanýlacaðýndan; BaseController oluþturulup diðer Controllerlara kalýtým verildi.
  BusinessRules Kýsmý:
    *LanguageBusinessRules.cs clasýnda "Ýsimler tekrar edemez" ve "Programlama dili boþ geçilemez" kurallarý yazýldý.
     Command kýsmýna kuralýmýz eklendi.
     ApplicationServiceRegistration.cs ye LanguageBusinessRules eklendi. 

4.AÞAMA
   Query kýsmý kodlandý.
     *GetListLanguageQuery.cs clasý oluþturuldu.
     *Controllerda GetList metotuyla MediatR a  GetlistLanguageQuery yollandý

   Fluent Validation uygulandý.
   Eklerken,güncellerken,silerken programlamadili ismi boþ olmamalý ve en az iki karakter olmalýdýr.(CreateLanguageCommandValidator.cs, UpdateLanguageCommandValidator.cs, DeleteLanguageCommandValidator)
   GetById ye göre tek bir data getirirkende geçersiz Id girme ihtimalinde karþý validation yazýldý (GetByIdLanguageQueryValidator.cs)

   *******************************************************************************
Sisteme programlama dillerine ait teknolojiler eklenebilmeli, silinebilmeli. güncellenebilmeli, listelenebilmelidir. Örneðin; Java : Spring, JSP. C#: WPF, ASP.NET , JavaScript : Vue, React
  
  1.AÞAMA
    *Technologies -> Domain entitysi oluþturuldu.
     Language(1)-Technologies(N) iliþkisi verilip migration yapýldý

  2.AÞAMA
    *Technologies Add -> CreateTechnologyCommand ile kullanýcý hangi Language ismine Technology ekleyecekse girer ve Technology tablosuna eklenir(LanguageId'siyle eklenir) 
    *Technologies Update -> UpdateTechnologyCommand ile kullanýcý hangi teknolojiyi güncelleyecekse Idsini ve LanguageId sini girer bunlar doðru ise Name ismini deðiþtirebilir 
    *Technologies Delete -> DeleteTechnologyCommand ile kullanýcý hangi teknolojiyi silecekse Id sini girer ve silinir
    *Fluent Validation uygulandý.Eklerken,Güncellerken,Silerken ve GetById ile tek bir data getirirken Id ve Name alanlarý kontrol edildi

    *Technologies GetList -> GetListTechnologyQuery ile Language isimleriyle birlikte listelendi 
    *Technologies GetListById -> GetListByIdTechnologyQuery ile Language isimiyle birlikte tek bir teknolojiyi getirir.
       Handle ederken Include ile tablolarý Joinledim.
       Mapping yaparkende LanguageName ismini Language tablosundan alýp eþleþtiriyorum
    *Technologies GetListByDynamic -> GetListTechnologyByDynamicQuery ile verileri dinamik filtre yaparak getirir

    
   *******************************************************************************
Core Packages altyapýsý kullanýlarak sisteme; 
 - Kullanýcýlar Register olup, Login olabilmelidir. (JWT)
 - Authentication yapýsý kuruldu.

1*Core.Security'ye Kullanýcýlar entitiesi oluþturuldu:
 User(N)- OperationClaim(N) olduðu için ->AraTablo oluþturuldu: User(1) -> UserOperationClaim(N) <- OperationClaim(1)
 RefreshToken tablosuda oluþturuldu.Jwt nin süresi dolduðunda kullanýcýyý sistemden atmasýn diye oluþturduk.Token ýn süresini uzatmamýzý saðlar.Örneðin kullanýcý ödeme yaparken sistemden düþmesinin önüne geçmiþ oluruz.
 BaseDbContext'e yeni tablolarýmýz implemente edilip, Migration yapýldý.  
2*Authentication iþlemleri için Auths Feature'u oluþturuldu.
  -RegisterCommand
  -RegisterDto, RefreshTokenDto larý oluþturuldu. Command de dýþardan alýncak veriler Dto'dan gelir.
  -Veritabanýna gitmek için Repositoryye ihtiyacým var -> IUserRepository,IRefreshTokenRepository ,IOperationClaimRepository,IUserOperationClaimRepository interfaceleri oluþturuldu.Bunlarýn Concreteleri de Persistence altýnda oluþturuldu.

3*ÝþKuralý
  Kullanýcý kayýt olduðunda ayný Email de kayýt varsa kontrolünü yapýp uyarý vermesi için;
  AuthBusinessRules classý oluþturuldu.

4*RegisterCommand -> hem veritabanýna kayýt iþlemlerini yapacak 
                     hemde Jwt Token üretecek

5*JwtToken üretme -> hem Register hemde Login olurken kullanýlacaðýndan Authentication iþlemleri için Servis oluþturuldu. ->Application-> AuthService-> IAuthService , AuthService

6*IpAddress'i GetIpAddress()metotuyla oluþturuyorum.Bunuda Login ve Register olurken kullancaðým için BaseController içine yazdým.